use axum::{
	extract::{Path, Request, State},
	middleware::{self, Next},
	response::{Json, Response},
	routing::{get, put},
	Extension, Router,
};
use graphql::data::RequestContext;
use models::{
	entity::{
		finished_reading_session, media, reading_session, registered_reading_device,
	},
	shared::enums::UserPermission,
};
use sea_orm::{prelude::*, sea_query::OnConflict, Iterable, Set, TransactionTrait};
use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

use crate::{
	config::state::AppState,
	errors::{APIError, APIResult},
	middleware::auth::api_key_middleware,
};

#[derive(Debug, Serialize, Deserialize)]
struct KOReaderURLParams<D> {
	#[serde(flatten)]
	params: D,
	#[serde(default)]
	api_key: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct KOReaderDocumentURLParams {
	document: String,
}

// TODO(koreader): healthcheck? I don't think it is required, since I could configure Stump as a
// sync server just fine without it.

/// Mounts the koreader sync router at `/koreader` (from the parent router). The endpoints are
/// derived from the official koreader API.
///
/// See https://github.com/koreader/koreader-sync-server/blob/master/config/routes.lua
pub(crate) fn mount(app_state: AppState) -> Router<AppState> {
	Router::new().nest(
		"/{api_key}",
		Router::new()
			.route("/users/auth", get(check_authorized))
			.route("/syncs/progress", put(put_progress))
			.route("/syncs/progress/{document}", get(get_progress))
			.layer(middleware::from_fn(authorize)) // Note the order!
			.layer(middleware::from_fn_with_state(
				app_state,
				api_key_middleware,
			)),
	)
}

/// A secondary authorization middleware to ensure that the user has access to the
/// koreader sync endpoints. This is purely for convenience
async fn authorize(req: Request, next: Next) -> APIResult<Response> {
	let ctx = req
		.extensions()
		.get::<RequestContext>()
		.ok_or(APIError::Unauthorized)?;
	ctx.enforce_permissions(&[UserPermission::AccessKoreaderSync])
		.map_err(|_| {
			APIError::Forbidden(
				"You do not have permission to use KOReader sync".to_string(),
			)
		})?;
	Ok(next.run(req).await)
}

#[derive(Serialize)]
struct CheckAuthorizedResponse {
	authorized: String,
}

async fn check_authorized() -> APIResult<Json<CheckAuthorizedResponse>> {
	Ok(Json(CheckAuthorizedResponse {
		authorized: "OK".to_string(),
	}))
}

#[skip_serializing_none]
#[derive(Default, Serialize, Deserialize)]
struct GetProgressResponse {
	/// A hash of the book, generated by koreader. This is used as an alternative method for
	/// identifying a book, since koreader is unaware of the book's ID in stump
	document: String,
	/// A string representing the current position in the book, as understood by koreader. This
	/// can be one of two things:
	///
	/// - A page number for page-based books (e.g. "24")
	/// - An x-pointer for DOM-based books, using their "scrolling" reader. This maps to the location
	///   in the DOM at the top of the screen at the time of sync. This is **not** an epubcfi string.
	///
	/// Please see this wonderful comment for additional context: https://github.com/stumpapp/stump/issues/239#issuecomment-2428256328
	progress: Option<String>,
	/// The reading progress of the book, as a percentage (0-1.0)
	percentage: Option<f32>,
	/// The name of the koreader device.
	device: Option<String>,
	/// The ID of the koreader device, generated by koreader. Stump will use this to identify a
	/// registered reading device, if one exists with the ID.
	device_id: Option<String>,
	/// The timestamp of the last progress update, in milliseconds since the Unix epoch.
	timestamp: Option<u64>,
}

async fn get_progress(
	State(ctx): State<AppState>,
	Extension(req): Extension<RequestContext>,
	Path(KOReaderURLParams {
		params: KOReaderDocumentURLParams { document },
		..
	}): Path<KOReaderURLParams<KOReaderDocumentURLParams>>,
) -> APIResult<Json<GetProgressResponse>> {
	let conn = ctx.conn.as_ref();
	let user = req.user();
	let document_cpy = document.clone();

	let active_session = reading_session::ModelWithDevice::find()
		.inner_join(media::Entity)
		.filter(reading_session::Column::UserId.eq(user.id.clone()))
		.filter(media::Column::KoreaderHash.eq(document_cpy.clone()))
		.into_model::<reading_session::ModelWithDevice>()
		.one(conn)
		.await?;

	let finished_session = finished_reading_session::ModelWithDevice::find()
		.inner_join(media::Entity)
		.filter(finished_reading_session::Column::UserId.eq(user.id.clone()))
		.filter(media::Column::KoreaderHash.eq(document_cpy))
		.into_model::<finished_reading_session::ModelWithDevice>()
		.one(conn)
		.await?;

	let progress = match (active_session, finished_session) {
		(Some(active_session), _) => GetProgressResponse {
			document,
			percentage: active_session
				.model
				.percentage_completed
				.map(|dec| dec.try_into().unwrap_or(0.0)),
			timestamp: Some(active_session.model.updated_at.timestamp_millis() as u64),
			device: active_session.device.as_ref().map(|d| d.name.clone()),
			device_id: active_session.device.as_ref().map(|d| d.id.clone()),
			progress: active_session
				.model
				.koreader_progress
				.or_else(|| active_session.model.page.map(|p| p.to_string())),
		},
		(_, Some(finished_session)) => GetProgressResponse {
			document,
			percentage: Some(1.0),
			timestamp: Some(finished_session.model.completed_at.timestamp_millis() as u64),
			device: finished_session.device.as_ref().map(|d| d.name.clone()),
			device_id: finished_session.device.as_ref().map(|d| d.id.clone()),
			..Default::default()
		},
		_ => GetProgressResponse {
			document,
			..Default::default()
		},
	};

	Ok(Json(progress))
}

enum NativeProgress {
	Page(i32),
	EpubCfi(String),
}

/// Attempts to parse the progress string into a native progress type. If the progress string
/// cannot be parsed, it is assumed to be an x-pointer. Stump does not support x-pointers, so
/// this function will return `None` in that case.
fn parse_progress(progress: &str) -> Option<NativeProgress> {
	// This is a super naive check, but it should be good enough for now. Eventually
	// I would really like to try and parse the x-pointer and translate it to a valid
	// epubcfi if possible. The closest I've seen online to an epubcfi parser in rust is
	// https://github.com/tnahs/readstor/blob/main/src/lib/models/epubcfi.rs. There are others
	// in JS that can be ported, as well
	if progress.starts_with("epubcfi(") && progress.ends_with(')') {
		Some(NativeProgress::EpubCfi(progress.to_string()))
	} else {
		progress.parse::<i32>().ok().map(NativeProgress::Page)
	}
}

#[derive(Deserialize)]
struct PutProgressInput {
	document: String,
	progress: String,
	percentage: f32,
	device: String,
	device_id: String,
}

#[derive(Deserialize, Serialize)]
struct PutProgressResponse {
	document: String,
	timestamp: u64,
}

async fn put_progress(
	State(ctx): State<AppState>,
	Extension(req): Extension<RequestContext>,
	Json(PutProgressInput {
		document,
		progress,
		percentage,
		device,
		device_id,
	}): Json<PutProgressInput>,
) -> APIResult<Json<PutProgressResponse>> {
	let conn = ctx.conn.as_ref();
	let user = req.user();

	if !(0.0..=1.0).contains(&percentage) {
		tracing::error!(
			percentage,
			"Invalid percentage provided for progress update"
		);
		return Err(APIError::BadRequest("Invalid percentage".to_string()));
	}

	let book = media::Entity::find()
		.filter(media::Column::KoreaderHash.eq(document.clone()))
		.one(conn)
		.await?
		.ok_or_else(|| APIError::NotFound("Book not found".to_string()))?;

	let is_completed = percentage == 1.0;
	let document_cpy = document.clone();

	let tx = ctx.conn.as_ref().begin().await?;

	let on_conflict = OnConflict::new()
		.update_columns(
			registered_reading_device::Column::iter()
				.filter(|col| matches!(col, registered_reading_device::Column::Name)),
		)
		.to_owned();

	let _device_record = registered_reading_device::Entity::insert(
		registered_reading_device::ActiveModel {
			id: Set(device_id.clone()),
			name: Set(device.clone()),
			..Default::default()
		},
	)
	.on_conflict(on_conflict)
	.exec(&tx)
	.await?;

	let existing_active_session = reading_session::Entity::find()
		.inner_join(media::Entity)
		.filter(reading_session::Column::UserId.eq(user.id.clone()))
		.filter(media::Column::KoreaderHash.eq(document_cpy.clone()))
		.one(&tx)
		.await?;

	let (active_session, finished_session) = if is_completed {
		let mut started_at = None;
		if let Some(active_session) = existing_active_session {
			started_at = Some(active_session.started_at);
			active_session.delete(&tx).await?;
		}

		let finished_session = finished_reading_session::ActiveModel {
			user_id: Set(user.id.clone()),
			media_id: Set(book.id.clone()),
			device_id: Set(Some(device_id.clone())),
			started_at: Set(started_at.unwrap_or_default()),
			..Default::default()
		};
		let finished_session = finished_session.insert(&tx).await?;

		(None, Some(finished_session))
	} else {
		let mut active_model = reading_session::ActiveModel {
			user_id: Set(user.id.clone()),
			media_id: Set(book.id.clone()),
			device_id: Set(Some(device_id.clone())),
			percentage_completed: Set(Decimal::try_from(percentage).ok()),
			koreader_progress: Set(Some(progress.clone())),
			..Default::default()
		};

		match parse_progress(&progress) {
			Some(NativeProgress::Page(page)) => {
				active_model.page = Set(Some(page));
			},
			Some(NativeProgress::EpubCfi(cfi)) => {
				active_model.epubcfi = Set(Some(cfi));
			},
			_ => {
				tracing::debug!(
					progress,
					"Failed to parse progress string, assuming x-pointer"
				);
			},
		};

		let active_session = reading_session::Entity::insert(active_model)
			.on_conflict(
				OnConflict::new()
					.update_columns(reading_session::Column::iter().filter(|col| {
						matches!(
							col,
							reading_session::Column::Page
								| reading_session::Column::Epubcfi
								| reading_session::Column::DeviceId
						)
					}))
					.to_owned(),
			)
			.exec_with_returning(&tx)
			.await?;

		(Some(active_session), None)
	};

	tx.commit().await?;

	let timestamp = match (active_session, finished_session) {
		(Some(active_session), _) => active_session.updated_at.timestamp_millis() as u64,
		(_, Some(finished_session)) => {
			finished_session.completed_at.timestamp_millis() as u64
		},
		_ => {
			tracing::error!("Failed to update progress!");
			return Err(APIError::InternalServerError(
				"Failed to update progress".to_string(),
			));
		},
	};

	Ok(Json(PutProgressResponse {
		document,
		timestamp,
	}))
}
