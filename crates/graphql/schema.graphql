type ActiveReadingSession {
	id: Int!
	page: Int
	percentageCompleted: Decimal
	epubcfi: String
	koreaderProgress: String
	startedAt: DateTime!
	updatedAt: DateTime!
	mediaId: String!
	userId: String!
	deviceId: String
	elapsedSeconds: Int
}

input AgeRestrictionInput {
	age: Int!
	restrictOnUnset: Boolean!
}

type Apikey {
	id: Int!
	name: String!
	shortToken: String!
	longTokenHash: String!
	createdAt: DateTime!
	lastUsedAt: DateTime
	expiresAt: DateTime
	userId: String!
	permissions: ApikeyPermissionsOutput!
}

input ApikeyInput {
	"The name of the API key"
	name: String!
	"The permissions that the API key should have"
	permissions: ApikeyPermissions!
	"The expiration date for the API key, if any"
	expiresAt: DateTime
}

input ApikeyPermissions @oneOf {
	inherit: InheritPermissionValue
	custom: [UserPermission!]
}

union ApikeyPermissionsOutput = InheritPermissionStruct | UserPermissionStruct

type Arrangement {
	locked: Boolean!
	sections: [ArrangementSection!]!
}

union ArrangementConfig = SystemArrangmentConfig | InProgressBooks | RecentlyAdded | CustomArrangementConfig

type ArrangementSection {
	config: ArrangementConfig!
	visible: Boolean!
}

"The metadata of an attachment that was sent with an email"
type AttachmentMeta {
	"The filename of the attachment"
	filename: String!
	"The associated media ID of the attachment, if there is one"
	mediaId: String
	"The size of the attachment in bytes"
	size: Int!
}

type BookClub {
	id: String!
	name: String!
	description: String
	isPrivate: Boolean!
	createdAt: DateTime!
	emoji: String
	currentBook: BookClubBook
	invitations: [BookClubInvitation!]!
	members: [BookClubMember!]!
	schedule: BookClubSchedule
}

union BookClubBook = BookClubInternalBook | BookClubExternalBook

input BookClubBookInput @oneOf {
	stored: BookClubInternalBookInput
	external: BookClubExternalBookInput
}

type BookClubExternalBook {
	title: String!
	author: String!
	url: String
	imageUrl: String
}

input BookClubExternalBookInput {
	title: String!
	author: String!
	url: String
	imageUrl: String
}

type BookClubInternalBook {
	id: String!
}

input BookClubInternalBookInput {
	id: String!
}

type BookClubInvitation {
	id: String!
	role: BookClubMemberRole!
	userId: String!
	bookClubId: String!
	"The book club that the user was invited to"
	bookClub: BookClub!
	"The user who was invited to the book club"
	user: User!
}

input BookClubInvitationInput {
	userId: String!
	role: BookClubMemberRole
}

input BookClubInvitationResponseInput {
	accept: Boolean!
	member: BookClubMemberInput
}

type BookClubMember {
	id: String!
	displayName: String
	isCreator: Boolean!
	hideProgress: Boolean!
	privateMembership: Boolean!
	role: BookClubMemberRole!
	userId: String!
	bookClubId: String!
}

input BookClubMemberInput {
	userId: String!
	displayName: String
	privateMembership: Boolean
}

"The visibility of a shareable entity"
enum BookClubMemberRole {
	MEMBER
	MODERATOR
	ADMIN
	CREATOR
}

type BookClubSchedule {
	id: Int!
	defaultIntervalDays: Int
	bookClubId: String!
	books: [BookClubBook!]!
}

type Bookmark {
	id: String!
	previewContent: String
	epubcfi: String
	page: Int
	mediaId: String!
	userId: String!
}

input BookmarkInput {
	mediaId: String!
	epubcfi: String!
	previewContent: String
}


type CleanLibraryResponse {
	deletedMediaCount: Int!
	deletedSeriesCount: Int!
	isEmpty: Boolean!
}

input CreateBookClubInput {
	name: String!
	isPrivate: Boolean! = false
	memberRoleSpec: JSON
	creatorHideProgress: Boolean!
	creatorDisplayName: String
}

input CreateBookClubMemberInput {
	userId: String!
	displayName: String
	privateMembership: Boolean
	role: BookClubMemberRole!
}

input CreateBookClubScheduleBook {
	book: BookClubBookInput!
	startAt: DateTime
	endAt: DateTime
	discussionDurationDays: Int
}

input CreateBookClubScheduleInput {
	defaultIntervalDays: Int
	books: [CreateBookClubScheduleBook!]!
}

input CreateOrUpdateLibraryInput {
	name: String!
	path: String!
	description: String
	emoji: String
	tags: [String!]
	config: LibraryConfigInput
	scanAfterPersist: Boolean!
}

input CreateUserInput {
	username: String!
	password: String!
	permissions: [UserPermission!]!
	ageRestriction: AgeRestrictionInput = null
	maxSessionsAllowed: Int
}

"A simple cursor-based pagination input object"
input CursorPagination {
	after: String
	limit: Int! = 20
}

"Information about the current cursor pagination state"
type CursorPaginationInfo {
	"""
	The cursor of the current page. This should only be None if there are no results,
	since there is no cursor present to pull from. This technically deviates from
	popular (read: Relay) specs, but it works better for Stump
	"""
	currentCursor: String
	"The cursor the next page should use, if it exists."
	nextCursor: String
	"The limit used when querying the database"
	limit: Int!
}

type CustomArrangementConfig {
	entity: FilterableArrangementEntity!
	name: String
	filter: JSON
	orderBy: String
	links: [FilterableArrangementEntityLink!]!
}

"""
Implement the DateTime<FixedOffset> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

scalar Decimal

type DirectoryListing {
	parent: String
	files: [DirectoryListingFile!]!
}

type DirectoryListingFile {
	isDirectory: Boolean!
	name: String!
	path: String!
}

input DirectoryListingInput {
	path: String
	ignoreHidden: Boolean! = true
	ignoreFiles: Boolean! = false
	ignoreDirectories: Boolean! = false
}

type DiscordConfig {
	webhookUrl: String!
}

input DiscordConfigInput {
	webhookUrl: String!
}

"Input object for creating or updating an email device"
input EmailDeviceInput {
	"The friendly name of the email device, e.g. \"Aaron's Kobo\""
	name: String!
	"The email address of the device"
	email: String!
	"Whether the device is forbidden from receiving emails from the server."
	forbidden: Boolean!
}

type Emailer {
	id: Int!
	name: String!
	isPrimary: Boolean!
	senderEmail: String!
	senderDisplayName: String!
	username: String!
	smtpHost: String!
	smtpPort: Int!
	tlsEnabled: Boolean!
	maxAttachmentSizeBytes: Int
	maxNumAttachments: Int
	lastUsedAt: DateTime
	sendHistory: [EmailerSendRecord!]!
}

"The configuration for an [EmailerClient]"
input EmailerClientConfig {
	"The email address to send from"
	senderEmail: String!
	"The display name to use for the sender"
	senderDisplayName: String!
	"The username to use for the SMTP server, typically the same as the sender email"
	username: String!
	"""
	The plaintext password to use for the SMTP server, which will be encrypted before being stored.
	This field is optional to support reusing the config for emailer config updates. If the password is not
	set, it will error when trying to send an email.
	"""
	password: String
	"The SMTP host to use"
	host: String!
	"The SMTP port to use"
	port: Int!
	"Whether to use TLS for the SMTP connection"
	tlsEnabled: Boolean!
	"The maximum size of an attachment in bytes"
	maxAttachmentSizeBytes: Int
	"The maximum number of attachments that can be sent in a single email"
	maxNumAttachments: Int
}

"Input object for creating or updating an emailer"
input EmailerInput {
	"The friendly name of the emailer, e.g. \"Aaron's Kobo\""
	name: String!
	"Whether the emailer is the primary emailer"
	isPrimary: Boolean!
	"The emailer configuration"
	config: EmailerClientConfig!
}

type EmailerSendRecord {
	id: Int!
	emailerId: Int!
	recipientEmail: String!
	sentAt: DateTime!
	sentByUserId: String
	sentBy: User
	attachmentMeta: [AttachmentMeta!]!
}

input EmailerSendTo @oneOf {
	device: SendToDevice
	anonymous: SendToEmail
}

"The visibility of a shareable entity"
enum EntityVisibility {
	PUBLIC
	SHARED
	PRIVATE
}

type Epub {
	mediaId: String!
	spine: [SpineItem!]!
	resources: JSONObject!
	toc: [String!]!
	metadata: JSONObject!
	rootBase: String!
	rootFile: String!
	extraCss: [String!]!
	annotations: [MediaAnnotationsModel!]!
	media: Media!
}

input EpubProgressInput {
	mediaId: String!
	epubcfi: String!
	percentage: Decimal!
	isComplete: Boolean
}

input EqualsString {
	eq: String!
}

input FieldFilterString @oneOf {
	eq: EqualsString
}

"The different statuses a file reference can have"
enum FileStatus {
	UNKNOWN
	READY
	UNSUPPORTED
	ERROR
	MISSING
}

enum FilterableArrangementEntity {
	BOOKS
	LIBRARIES
	SERIES
	SMART_LISTS
	BOOK_CLUBS
}

enum FilterableArrangementEntityLink {
	CREATE
	SHOW_ALL
}

type FinishedReadingSession {
	id: Int!
	startedAt: DateTime!
	completedAt: DateTime!
	mediaId: String!
	userId: String!
	deviceId: String
	elapsedSeconds: Int
}



type ImageRef {
	url: String!
	height: Int
	width: Int
}

type InProgressBooks {
	name: String
	links: [FilterableArrangementEntityLink!]!
}

type InheritPermissionStruct {
	value: InheritPermissionValue!
}

enum InheritPermissionValue {
	INHERIT
}


"A scalar that can represent any JSON value."
scalar JSON

"A scalar that can represent any JSON Object value."
scalar JSONObject

type Library {
	id: String!
	name: String!
	description: String
	path: String!
	status: FileStatus!
	updatedAt: DateTime!
	createdAt: DateTime!
	emoji: String
	configId: Int!
	jobScheduleConfigId: String
	lastScannedAt: String
	config: LibraryConfig!
	excludedUsers: [User!]!
	"Get the details of the last scan job for this library, if any exists."
	lastScan: LibraryScanRecordModel
	"Get the full history of scan jobs for this library."
	scanHistory: [LibraryScanRecordModel!]!
	series: [Series!]!
	stats(allUsers: Boolean): LibraryStats!
	tags: [Tag!]!
}

type LibraryConfig {
	id: Int!
	convertRarToZip: Boolean!
	hardDeleteConversions: Boolean!
	defaultReadingDir: ReadingDirection!
	defaultReadingMode: ReadingMode!
	defaultReadingImageScaleFit: ReadingImageScaleFit!
	generateFileHashes: Boolean!
	generateKoreaderHashes: Boolean!
	processMetadata: Boolean!
	watch: Boolean!
	libraryPattern: LibraryPattern!
	libraryId: String
	imageProcessorOptions: JSON
	ignoreRules: [String!]
}

input LibraryConfigInput {
	convertRarToZip: Boolean!
	hardDeleteConversions: Boolean!
	generateFileHashes: Boolean!
	generateKoreaderHashes: Boolean!
	processMetadata: Boolean!
	watch: Boolean!
	libraryPattern: LibraryPattern!
	thumbnailConfig: JSON
	defaultReadingDir: ReadingDirection!
	defaultReadingMode: ReadingMode!
	defaultReadingImageScaleFit: ReadingImageScaleFit!
	ignoreRules: [String!]
}

"The different patterns a library may be organized by"
enum LibraryPattern {
	SERIES_BASED
	COLLECTION_BASED
}

type LibraryScanRecordModel {
	id: Int!
	options: [Int!]
	timestamp: DateTime!
	libraryId: String!
	jobId: String
}

type LibraryStats {
	seriesCount: Int!
	bookCount: Int!
	totalBytes: Int!
	completedBooks: Int!
	inProgressBooks: Int!
}

type Log {
	id: Int!
	level: String!
	message: String!
	timestamp: DateTime!
	jobId: String
	context: String
}

type LogDeleteOutput {
	deleted: Int!
}

type LogFileInfo {
	path: String!
	size: Int!
	modified: String!
}

type Media {
	"The unique identifier for the media"
	id: String!
	"The name of the media, derived from the filename and excluding the extension"
	name: String!
	"The size of the media file in bytes"
	size: Int!
	"The extension of the media file, excluding the leading period"
	extension: String!
	"The number of pages in the media, if applicable. Will be -1 for certain media types"
	pages: Int!
	"The timestamp of the last time the media was updated. This will be set during creation, as well"
	updatedAt: DateTime!
	"The timestamp of the creation of the media"
	createdAt: DateTime!
	"""
	The timestamp of when the underlying file was last modified on disk. This will only be set if
	a timestamp can be retrieved from the filesystem
	"""
	modifiedAt: DateTime
	"""
	A Stump-specific hash of the media file. This is used as a secondary identifier for the media, primarily
	in aiding in the identification of duplicate media files
	"""
	hash: String
	"""
	A hash of the media file that adheres to the KoReader hash algorithm. This is used to identify
	books from the KoReader application so progress can be synced between the two applications
	"""
	koreaderHash: String
	"The path of the underlying media file on disk"
	path: String!
	"""
	The status of the media. This is used to determine if the media is available for reading (i.e.,
	if it is available on disk)
	"""
	status: FileStatus!
	"""
	The unique identifier of the series that the media belongs to. While this is nullable, it is
	expected that all media will belong to a series
	"""
	seriesId: String
	"The timestamp of when the media was **soft** deleted. This will act like a trash bin."
	deletedAt: DateTime
	metadata: MediaMetadata
	series: Series!
	library: Library!
	"""
	A reference to the thumbnail image for the media. This will be a fully
	qualified URL to the image.
	"""
	thumbnail: ImageRef!
	"""
	The resolved name of the media, which will prioritize the title pulled from
	metatadata, if available, and fallback to the name derived from the file name
	"""
	resolvedName: String!
	readProgress: ActiveReadingSession
	readHistory: [FinishedReadingSession!]!
	"The next media in the series, ordered by name"
	nextInSeries(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedMediaResponse!
	"""
	The path to the media file **relative** to the library path. This is only useful for
	displaying a truncated path when in the context of a library, e.g. limited space
	on a mobile device.
	"""
	relativeLibraryPath: String!
}

type MediaAnnotationsModel {
	id: String!
	highlightedText: String
	epubcfi: String
	page: Int
	pageCoordinatesX: Decimal
	pageCoordinatesY: Decimal
	notes: String
	userId: String!
	mediaId: String!
}

input MediaFilterInputTest {
	name: FieldFilterString
}

type MediaMetadata {
	id: Int!
	mediaId: String
	title: String
	series: String
	number: Decimal
	volume: Int
	summary: String
	notes: String
	genre: String
	year: Int
	month: Int
	day: Int
	pageCount: Int
	ageRating: Int
	pageAnalysis: PageAnalysis
	characters: [String!]!
	colorists: [String!]!
	coverArtists: [String!]!
	editors: [String!]!
	inkers: [String!]!
	letterers: [String!]!
	links: [String!]!
	pencillers: [String!]!
	teams: [String!]!
}

type MediaMetadataOverview {
	genres: [String!]!
	writers: [String!]!
	pencillers: [String!]!
	inkers: [String!]!
	colorists: [String!]!
	letterers: [String!]!
	editors: [String!]!
	publishers: [String!]!
	characters: [String!]!
	teams: [String!]!
}

type Mutation {
	createApiKey(input: ApikeyInput!): Apikey!
	updateApiKey(id: Int!, input: ApikeyInput!): Apikey!
	deleteApiKey(id: Int!): Apikey!
	createBookClub(input: CreateBookClubInput!): BookClub!
	updateBookClub(id: ID!, input: UpdateBookClubInput!): BookClub!
	createBookClubInvitation(id: ID!, input: BookClubInvitationInput!): BookClubInvitation!
	respondToBookClubInvitation(id: ID!, input: BookClubInvitationResponseInput!): BookClubInvitation!
	createBookClubMember(bookClubId: ID!, input: CreateBookClubMemberInput!): BookClubMember!
	createBookClubSchedule(id: ID!, input: CreateBookClubScheduleInput!): BookClub!
	addBooksToBookClubSchedule(id: ID!, books: [CreateBookClubScheduleBook!]!): BookClub!
	createNotifier(input: NotifierInput!): Notifier!
	updateNotifier(id: Int!, input: NotifierInput!): Notifier!
	deleteNotifier(id: Int!): Notifier!
	"""
	Update the progress of an epub for a user. If the percentage is 1 or greater, the epub is
	considered finished and the active session is deleted and a finished session is created.
	
	If the epub is already finished and the percentage is 1 or greater, the old finished
	session is deleted and a new one is created.
	"""
	updateEpubProgress(input: EpubProgressInput!): ReadingProgressOutput!
	"""
	Create or update a bookmark for a user. If a bookmark already exists for the given media
	and epubcfi, the preview content is updated.
	"""
	createOrUpdateBookmark(input: BookmarkInput!): Bookmark!
	"Delete a bookmark by ID. The user must be the owner of the bookmark."
	deleteBookmark(id: ID!): Bookmark!
	analyzeMedia(id: ID!): Boolean!
	convertMedia(id: ID!): Boolean!
	deleteMediaProgress(id: ID!): Media!
	updateMediaProgress(id: ID!, page: Int): ReadingProgressOutput!
	"""
	Delete media and series from a library that match one of the following conditions:
	
	- A series that is missing from disk (status is not `Ready`)
	- A media that is missing from disk (status is not `Ready`)
	- A series that is not associated with any media (i.e., no media in the series)
	
	This operation will also remove any associated thumbnails of the deleted media and series.
	"""
	cleanLibrary(id: ID!): CleanLibraryResponse!
	"""
	Create a new library with the provided configuration. If `scan_after_persist` is `true`,
	the library will be scanned immediately after creation.
	"""
	createLibrary(input: CreateOrUpdateLibraryInput!): Library!
	"""
	Update an existing library with the provided configuration. If `scan_after_persist` is `true`,
	the library will be scanned immediately after updating.
	"""
	updateLibrary(id: ID!, input: CreateOrUpdateLibraryInput!): Library!
	"""
	Exclude users from a library, preventing them from seeing the library in the UI. This operates as a
	full replacement of the excluded users list, so any users not included in the provided list will be
	removed from the exclusion list if they were previously excluded.
	
	The server owner cannot be excluded from a library, nor can the user performing the action exclude
	themselves.
	"""
	updateLibraryExcludedUsers(id: ID!, userIds: [String!]!): Library!
	deleteLibraryScanHistory(id: ID!): Library!
	"""
	Delete a library, including all associated media and series via cascading deletes. This
	operation cannot be undone.
	"""
	deleteLibrary(id: ID!): Library!
	"""
	Enqueue a scan job for a library. This will index the filesystem from the library's root path
	and update the database accordingly.
	"""
	scanLibrary(id: ID!, option: JSON): Boolean!
	"""
	"Visit" a library, which will upsert a record of the user's last visit to the library.
	This is used to inform the UI of the last library which was visited by the user
	"""
	visitLibrary(id: ID!): Library!
	deleteLogs: LogDeleteOutput!
	deleteLogFile: Boolean!
	"""
	Creates a new reading list.
	
	# Returns
	
	A result containing the newly created reading list, or an error if creation failed.
	"""
	createReadingList(input: ReadingListInput!): ReadingList!
	"""
	Updates an existing reading list.
	
	# Returns
	
	A result containing the updated reading list, or an error if update failed.
	"""
	updateReadingList(input: ReadingListInput!): ReadingList!
	"""
	Deletes a reading list by ID.
	
	# Returns
	
	A result containing the deleted reading list, or an error if deletion failed.
	"""
	deleteReadingList(id: String!): ReadingList!
	analyzeSeries(id: ID!): Boolean!
	markSeriesAsComplete(id: ID!): Series!
	scanSeries(id: ID!): Boolean!
	"""
	Returns a list containing the newly created tags, or an error if creation failed.
	
	If any of the tags already exist an error is returned.
	
	* `tags` - A non-empty list of tags to create.
	"""
	createTags(tags: [String!]!): [Tag!]!
	"""
	Delete tags. Returns a list containing the deleted tags, or an error if deletion failed.
	
	* `tags` - A non-empty list of tags to create.
	"""
	deleteTags(tags: [String!]!): [Tag!]!
	uploadBooks(input: UploadBooksInput!): Boolean!
	uploadSeries(input: UploadSeriesInput!): Boolean!
	deleteLoginActivity: Int!
	createUser(input: CreateUserInput!): User!
	meUpdateUser(input: UpdateUserInput!): User!
	meUpdateUserPreferences(input: UpdateUserPreferencesInput!): UserPreferences!
	updateUser(userId: String!, input: UpdateUserInput!): User!
	deleteUserById(userId: String!, hardDelete: Boolean): User!
	deleteUserSessions(userId: String!): Int!
	updateUserLockStatus(userId: String!, lock: Boolean!): User!
	createEmailer(input: EmailerInput!): Emailer!
	updateEmailer(id: Int!, input: EmailerInput!): Emailer!
	deleteEmailer(id: Int!): Emailer!
	sendAttachmentEmail(input: SendAttachmentEmailsInput!): SendAttachmentEmailOutput!
	createEmailDevice(input: EmailDeviceInput!): RegisteredEmailDevice!
	updateEmailDevice(id: Int!, input: EmailDeviceInput!): RegisteredEmailDevice!
	patchEmailDevice(id: Int!, input: EmailDeviceInput!): Int!
	deleteEmailDevice(id: Int!): RegisteredEmailDevice!
}

type Notifier {
	id: Int!
	type: String!
	config: NotifierConfig!
}

union NotifierConfig = DiscordConfig | TelegramConfig

input NotifierInput @oneOf {
	discord: DiscordConfigInput
	telegram: TelegramConfigInput
}

"A simple offset-based pagination input object"
input OffsetPagination {
	"""
	The page to start from. This is 1-based by default, but can be
	changed to 0-based by setting the `zero_based` field to true.
	"""
	page: Int!
	"The number of items to return per page. This is 20 by default."
	pageSize: Int = 20
	"Whether or not the page is zero-based. This is false by default."
	zeroBased: Boolean = false
}

"Information about the current offset pagination state"
type OffsetPaginationInfo {
	"""
	The number of pages available. This is **not** affected by the zero-based flag,
	so a client requesting zero-based pagination will need to adjust their pagination
	logic accordingly.
	"""
	totalPages: Int!
	"The current page, zero-indexed."
	currentPage: Int!
	"The number of elements per page."
	pageSize: Int!
	"The offset of the current page. E.g. if current page is 1, and pageSize is 10, the offset is 20."
	pageOffset: Int!
	"Whether or not the page is zero-indexed."
	zeroBased: Boolean!
}

"A struct containing the various analyses of a book in Stump, e.g., page dimensions."
type PageAnalysis {
	dimensions: [PageDimension!]!
}

"""
Represents a page dimension for a page of a Stump media item. It consists of a
height and a width.
"""
type PageDimension {
	height: Int!
	width: Int!
}

type PaginatedDirectoryListingResponse {
	nodes: [DirectoryListing!]!
	pageInfo: PaginationInfo!
}

type PaginatedLibraryResponse {
	nodes: [Library!]!
	pageInfo: PaginationInfo!
}

type PaginatedLogResponse {
	nodes: [Log!]!
	pageInfo: PaginationInfo!
}

type PaginatedMediaResponse {
	nodes: [Media!]!
	pageInfo: PaginationInfo!
}

type PaginatedReadingListResponse {
	nodes: [ReadingList!]!
	pageInfo: PaginationInfo!
}

type PaginatedSeriesResponse {
	nodes: [Series!]!
	pageInfo: PaginationInfo!
}

"""
A union of the supported pagination flavors which Stump supports. The resulting
response will be dependent on the pagination type used, e.g. a [CursorPaginatedResponse]
will be returned if the [CursorPagination] type is used.

You may use a conditional fragment in your GraphQL query for type-specific fields:
```graphql
query MyQuery {
media(pagination: { offset: { page: 1, pageSize: 20 } }) {
... on OffsetPaginationInfo {
totalPages
currentPage
}
}
}
```

A special case is the `None` variant, which will return an offset-based pagination info
object based on the size of the result set. This will not paginate the results, so be
cautious when using this with large result sets.

**Note**: Be sure to call [Pagination::resolve] before using the pagination object
to ensure that the pagination object is in a valid state.
"""
input Pagination @oneOf {
	cursor: CursorPagination
	offset: OffsetPagination
	none: Unpaginated
}

union PaginationInfo = CursorPaginationInfo | OffsetPaginationInfo

type Query {
	getApiKeys: [Apikey!]!
	getApiKeyById(id: Int!): Apikey!
	bookClubs(all: Boolean = null): [BookClub!]!
	bookClubById(id: ID!): BookClub
	emailers: [Emailer!]!
	emailerById(id: ID!): Emailer
	emailDevices: [RegisteredEmailDevice!]!
	emailDeviceById(id: Int!): RegisteredEmailDevice
	listDirectory(pagination: Pagination!, input: DirectoryListingInput): PaginatedDirectoryListingResponse!
	test(filter: MediaFilterInputTest!): String!
	media(filter: JSON! = "{}", pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedMediaResponse!
	mediaById(id: ID!): Media
	mediaByPath(path: String!): Media
	keepReading(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedMediaResponse!
	recentlyAddedMedia(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedMediaResponse!
	duplicateMedia: [Media!]!
	me: User!
	users: [User!]!
	userById(id: ID!): User!
	loginActivity: [UserLoginActivity!]!
	loginActivityById(id: ID!): [UserLoginActivity!]!
	getNotifiers: [Notifier!]!
	getNotifierById(id: Int!): Notifier!
	"""
	Retrieves a paginated list of reading lists for the current user.
	
	# Returns
	
	A paginated list of reading lists.
	"""
	readingLists(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedReadingListResponse!
	"""
	Retrieves a reading list by ID for the current user.
	
	# Returns
	A reading list with the given ID. If no reading list with this ID exists for the current user, an error will be returned.
	"""
	readingListById(id: ID!): ReadingList!
	"Get a single epub by its media ID"
	epubById(id: ID!): Epub!
	"Get all bookmarks for a single epub by its media ID"
	bookmarksByMediaId(id: ID!): [Bookmark!]!
	libraries(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedLibraryResponse!
	libraryById(id: ID!): Library
	numberOfLibraries: Int!
	mediaMetadataOverview: MediaMetadataOverview!
	series(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedSeriesResponse!
	seriesById(id: ID!): Series
	numberOfSeries: Int!
	recentlyAddedSeries(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedSeriesResponse!
	"Returns a list of all tags."
	tags: [Tag!]!
	logs(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedLogResponse!
	"""
	Get information about the Stump log file, located at STUMP_CONFIG_DIR/Stump.log, or
	~/.stump/Stump.log by default. Information such as the file size, last modified date, etc.
	"""
	logfileInfo: LogFileInfo!
	stumpConfig: StumpConfig!
	uploadConfig: UploadConfig!
}

"The different reading directions supported by any Stump reader"
enum ReadingDirection {
	LTR
	RTL
}

"The different ways an image may be scaled to fit a reader's viewport"
enum ReadingImageScaleFit {
	HEIGHT
	WIDTH
	NONE
}

type ReadingList {
	id: String!
	name: String!
	description: String
	updatedAt: DateTime!
	visibility: String!
	ordering: String!
	creatingUserId: String!
}

input ReadingListInput {
	id: String!
	name: String!
	visibility: EntityVisibility
	mediaIds: [String!]!
}

"The different reading modes supported by any Stump reader"
enum ReadingMode {
	PAGED
	CONTINUOUS_VERTICAL
	CONTINUOUS_HORIZONTAL
}

type ReadingProgressOutput {
	activeSession: ActiveReadingSession
	finishedSession: FinishedReadingSession
}

type RecentlyAdded {
	entity: FilterableArrangementEntity!
	name: String
	links: [FilterableArrangementEntityLink!]!
}

type RegisteredEmailDevice {
	id: Int!
	name: String!
	email: String!
	forbidden: Boolean!
	sendHistory: [EmailerSendRecord!]!
}

type SendAttachmentEmailOutput {
	sentCount: Int!
	errors: [String!]!
}

input SendAttachmentEmailsInput {
	mediaIds: [String!]!
	sendTo: [EmailerSendTo!]!
}

input SendToDevice {
	id: Int!
}

input SendToEmail {
	email: String!
}

type Series {
	id: String!
	name: String!
	description: String
	updatedAt: DateTime!
	createdAt: DateTime!
	path: String!
	status: FileStatus!
	libraryId: String
	metadata: SeriesMetadataModel
	resolvedName: String!
	resolvedDescription: String
	library: Library!
	media: [Media!]!
	mediaCount: Int!
	upNext(take: Int! = 1, cursor: String): [Media!]!
	isComplete: Boolean!
	percentageCompleted: Float!
	readCount: Int!
	unreadCount: Int!
	tags: [Tag!]!
}

type SeriesMetadataModel {
	metaType: String!
	title: String
	summary: String
	publisher: String
	imprint: String
	comicid: Int
	volume: Int
	booktype: String
	ageRating: Int
	status: String
	seriesId: String!
}

type SpineItem {
	idref: String!
	id: String
	properties: String
	linear: Boolean!
}


"""
Represents the configuration of a Stump application. This struct is generated at startup
using a TOML file, environment variables, or both and is input when creating a `StumpCore`
instance.

Example:
```
use stump_core::{config::{self, StumpConfig}, StumpCore};

#[tokio::main]
async fn main() {
/// Get config dir from environment variables.
let config_dir = config::bootstrap_config_dir();

// Create a StumpConfig using the config file and environment variables.
let config = StumpConfig::new(config_dir)
// Load Stump.toml file (if any)
.with_config_file().unwrap()
// Overlay environment variables
.with_environment().unwrap();

// Ensure that config directory exists and write Stump.toml.
config.write_config_dir().unwrap();
// Create an instance of the stump core.
let core = StumpCore::new(config).await;
}
```
"""
type StumpConfig {
	"The \"release\" | \"debug\" profile with which the application is running."
	profile: String!
	"The port from which to serve the application (default: 10801)."
	port: Int!
	"The verbosity with which to log errors (default: 0)."
	verbosity: Int!
	"Whether or not to pretty print logs."
	prettyLogs: Boolean!
	"An optional custom path for the database."
	dbPath: String
	"The client directory."
	clientDir: String!
	"An optional custom path for the templates directory."
	customTemplatesDir: String
	"The configuration root for the Stump application, contains thumbnails, cache, and logs."
	configDir: String!
	"A list of origins for CORS."
	allowedOrigins: [String!]!
	"Path to the PDFium binary for PDF support."
	pdfiumPath: String
	"Indicates if the Swagger UI should be disabled."
	enableSwagger: Boolean!
	"Indicates if the KoReader sync feature should be enabled."
	enableKoreaderSync: Boolean!
	"Password hash cost"
	passwordHashCost: Int!
	"The time in seconds that a login session will be valid for."
	sessionTtl: Int!
	accessTokenTtl: Int!
	"The interval at which automatic deleted session cleanup is performed."
	expiredSessionCleanupInterval: Int!
	"""
	The maximum number of concurrent files which may be processed by a scanner. This is used
	to limit/increase the number of files that are processed at once. This may be useful for those
	with high or low performance systems to configure to their needs.
	"""
	maxScannerConcurrency: Int!
	"""
	The maximum number of concurrent files which may be processed by a thumbnail generator. This is used
	to limit/increase the number of images that are processed at once. Image generation can be
	resource intensive, so this may be useful for those with high or low performance systems to
	configure to their needs.
	"""
	maxThumbnailConcurrency: Int!
	"""
	The maximum file size, in bytes, of images that can be uploaded, e.g., as thumbnails for users,
	libraries, series, or media.
	"""
	maxImageUploadSize: Int!
	"Whether or not the server will allow users with the appropriate permissions to upload books and series."
	enableUpload: Boolean!
	"The maximum size, in bytes, of files that can be uploaded to be included in libraries."
	maxFileUploadSize: Int!
}

type Subscription {
	tailLogFile: String!
}

enum SupportedFont {
	ATKINSON_HYPERLEGIBLE
	BITTER
	CHARIS
	INTER
	LIBRE_BASKERVILLE
	LITERATA
	NUNITO
	OPEN_DYSLEXIC
}

enum SystemArrangment {
	HOME
	EXPLORE
}

type SystemArrangmentConfig {
	variant: SystemArrangment!
}

type Tag {
	id: String!
	name: String!
}

type TelegramConfig {
	encryptedToken: String!
	chatId: String!
}

input TelegramConfigInput {
	token: String!
	chatId: String!
}

"""
A simple pagination input object which does not paginate. An explicit struct is
required as a limitation of async_graphql's [OneofObject], which doesn't allow
for empty variants.
"""
input Unpaginated {
	unpaginated: Boolean!
}

input UpdateBookClubInput {
	name: String
	description: String
	isPrivate: Boolean
	memberRoleSpec: JSON
	emoji: String
}

input UpdateUserInput {
	username: String!
	password: String
	avatarUrl: String
	permissions: [UserPermission!]!
	ageRestriction: AgeRestrictionInput = null
	maxSessionsAllowed: Int
}

input UpdateUserPreferencesInput {
	locale: String!
	preferredLayoutMode: String!
	primaryNavigationMode: String!
	layoutMaxWidthPx: Int
	appTheme: String!
	enableGradients: Boolean!
	appFont: SupportedFont!
	showQueryIndicator: Boolean!
	enableLiveRefetch: Boolean!
	enableDiscordPresence: Boolean!
	enableCompactDisplay: Boolean!
	enableDoubleSidebar: Boolean!
	enableReplacePrimarySidebar: Boolean!
	enableHideScrollbar: Boolean!
	enableJobOverlay: Boolean!
	preferAccentColor: Boolean!
	showThumbnailsInHeaders: Boolean!
}

scalar Upload

input UploadBooksInput {
	libraryId: String!
	placeAt: String!
	uploads: [Upload!]!
}

type UploadConfig {
	enabled: Boolean!
	maxFileUploadSize: Int!
}

input UploadSeriesInput {
	libraryId: String!
	placeAt: String!
	seriesDirName: String!
	upload: Upload!
}

type User {
	id: String!
	username: String!
	isServerOwner: Boolean!
	avatarUrl: String
	lastLogin: DateTime
	createdAt: DateTime!
	deletedAt: DateTime
	isLocked: Boolean!
	maxSessionsAllowed: Int
	continueReading(pagination: Pagination! = {offset: {page: 1, pageSize: 20, zeroBased: false}}): PaginatedMediaResponse!
	permissions: [UserPermission!]!
	preferences: UserPreferences!
}

type UserLoginActivity {
	id: Int!
	ipAddress: String!
	userAgent: String!
	authenticationSuccessful: Boolean!
	timestamp: DateTime!
	userId: String!
	user: User!
}

"The permissions a user may be granted"
enum UserPermission {
	"Grant access to read/create their own API keys"
	ACCESS_API_KEYS
	"Grant access to the koreader sync feature"
	ACCESS_KOREADER_SYNC
	"""
	TODO: Expand permissions for bookclub + smartlist
	Grant access to the book club feature
	"""
	ACCESS_BOOK_CLUB
	"Grant access to create a book club (access book club)"
	CREATE_BOOK_CLUB
	"Grant access to read any emailers in the system"
	EMAILER_READ
	"Grant access to create an emailer"
	EMAILER_CREATE
	"Grant access to manage an emailer"
	EMAILER_MANAGE
	"Grant access to send an email"
	EMAIL_SEND
	"Grant access to send an arbitrary email, bypassing any registered device requirements"
	EMAIL_ARBITRARY_SEND
	"Grant access to access the smart list feature. This includes the ability to create and edit smart lists"
	ACCESS_SMART_LIST
	"Grant access to access the file explorer"
	FILE_EXPLORER
	"Grant access to upload files to a library"
	UPLOAD_FILE
	"Grant access to download files from a library"
	DOWNLOAD_FILE
	"Grant access to create a library"
	CREATE_LIBRARY
	"Grant access to edit basic details about the library"
	EDIT_LIBRARY
	"Grant access to scan the library for new files"
	SCAN_LIBRARY
	"Grant access to manage the library (scan,edit,manage relations)"
	MANAGE_LIBRARY
	"Grant access to delete the library (manage library)"
	DELETE_LIBRARY
	"""
	Grant access to read users.
	
	Note that this is explicitly for querying users via user-specific endpoints.
	This would not affect relational queries, such as members in a common book club.
	"""
	READ_USERS
	"Grant access to manage users (create,edit,delete)"
	MANAGE_USERS
	READ_NOTIFIER
	"Grant access to create a notifier"
	CREATE_NOTIFIER
	"Grant access to manage a notifier"
	MANAGE_NOTIFIER
	"Grant access to delete a notifier"
	DELETE_NOTIFIER
	"Grant access to manage the server. This is effectively a step below server owner"
	MANAGE_SERVER
}

type UserPermissionStruct {
	value: [UserPermission!]!
}

type UserPreferences {
	id: String!
	preferredLayoutMode: String!
	locale: String!
	appTheme: String!
	appFont: String!
	primaryNavigationMode: String!
	layoutMaxWidthPx: Int
	showQueryIndicator: Boolean!
	enableLiveRefetch: Boolean!
	enableDiscordPresence: Boolean!
	enableCompactDisplay: Boolean!
	enableGradients: Boolean!
	enableDoubleSidebar: Boolean!
	enableReplacePrimarySidebar: Boolean!
	enableHideScrollbar: Boolean!
	preferAccentColor: Boolean!
	showThumbnailsInHeaders: Boolean!
	enableJobOverlay: Boolean!
	enableAlphabetSelect: Boolean!
	userId: String
	homeArrangement: Arrangement!
	navigationArrangement: Arrangement!
}

directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @oneOf on INPUT_OBJECT
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @specifiedBy(url: String!) on SCALAR
schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}
