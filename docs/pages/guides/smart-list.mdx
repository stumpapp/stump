import { Callout } from 'nextra/components'

# Smart lists

A smart list is a dynamic list of books generated from a set of configured filters. They are powerful in that they allow you to quickly curate and organize a collection of books based on a set of criteria without having to manually manage the list.

## Filters

The core of a smart list, used for determining which books are to be included in the resulting list.

A smart lists filter configuration is made up of two parts:

- **Groups**: Sub-lists of filters that are combined together using a top-level joiner (see below)
- **Top-level joiner**: The method used to join groups together, i.e. `AND` or `OR` (all groups must match vs at least one group must match)

A group itself has two parts:

- **Joiner**: The method used to join filters together within the group, i.e. `AND`, `OR`, `NOT` (all filters must match, at least one filter must match, or no filters must match)
- **Conditions**: A list of filters to apply to the books

A condition in a filter group has the following structure:

- **Attribute**: The attribute of the book to filter on. This also allows selecting attributes of related entities, such as a book's metadata, series, or library. I won't enumerate them all, but you can filter on most attributes. Any missing attributes can be requested!
- **Operator**: The operator to use when comparing the attribute to the value. I won't enumerate them all, but you have options for string and list matching, number comparison, and range operators
- **Value**: The actual value to compare the attribute to. The UI presents this dynamically, based on the attribute and operator selected

### Grouping

Not to be confused with the filter groups, grouping is a way of grouping matched books together by a common attribute. At the time of writing, there are 3 grouping options:

1. `BY_SERIES`: Groups books together by their series
2. `BY_LIBRARY`: Groups books together by their library
3. `BY_BOOKS`: Does not group books together. The name is perhaps confusing, but you can think of it as "no grouping"

In the future, more grouping options may be considered

## Feature Access

The smart list feature, itself, is gated behind the `smartlist:read` user permission. This means that only users with this permission will be able to interact with smart lists.

## List-level Access

Smart lists can be shared with other users, and has 3 visibility options:

- **Private**: Only the owner of the smart list can see it
- **Public**: Anyone can see the smart list
- **Shared**: Only users that the smart list has been shared with can see it

<Callout emoji="ðŸš§">
	The `shared` visibility option is not yet fully implemented. It functions as `private` for now,
	but will be updated in the future
</Callout>

## Creating a Smart List

There is a query builder directly in the UI which allows you to declaratively create a smart list. This is the recommended way to create a smart list, as it is the most user-friendly. The UI is aware of the type-constraints per attribute and will guide you through the process.

You can also use the API directly, an example `POST` request might look like this:

```json
{
	"name": "Spider-Man Collection",
	"description": "A smart list that aggregates all of my Spider-Man-related comics into one place",
	"filter": {
		"groups": [
			{
				"or": [
					{
						"name": {
							"contains": "spider"
						}
					},
					{
						"metadata": {
							"characters": {
								"contains": "spider-man"
							}
						}
					}
				]
			},
			{
				"and": [
					{
						"series": {
							"library": {
								"name": {
									"excludes": "Books"
								}
							}
						}
					}
				]
			}
		],
		"joiner": "AND"
	},
	"default_grouping": "BY_SERIES"
}
```

## Views

While interacting with a smart list on the UI, you can manipulate the view to your liking. This includes:

- Sorting states for the table
- Column visibility, i.e. which columns are visible or hidden
- Column order, i.e. the order in which columns are displayed

By default, any changes you make won't be persisted. However, the UI will detect and allow you to save any adjustments as a view. This view will then be available to you in the future, along with any other views you create. If you have a view selected, the changes will provide you with the additional option of updating the view.
