// DO NOT MODIFY THIS FILE, IT IS AUTOGENERATED

// CORE TYPE GENERATION

export type PaginationQuery = { zero_based?: boolean | null; page?: number | null; page_size?: number | null; cursor?: string | null; limit?: number | null }

/**
 * An event that is emitted by the core and consumed by a client
 */
export type CoreEvent = ({ __typename: "JobStarted" } & string) | ({ __typename: "JobUpdate" } & JobUpdate) | { __typename: "JobOutput"; id: string; output: CoreJobOutput } | ({ __typename: "DiscoveredMissingLibrary" } & string) | { __typename: "CreatedMedia"; id: string; series_id: string } | { __typename: "CreatedManySeries"; count: number; library_id: string } | { __typename: "CreatedOrUpdatedManyMedia"; count: number; series_id: string }

export type EntityVisibility = "PUBLIC" | "SHARED" | "PRIVATE"

export type AccessRole = "Reader" | "Writer" | "CoCreator"

/**
 * A model representing a persisted log entry. These are different than traces/system logs.
 */
export type Log = { id: number; level: LogLevel; message: string; context: string | null; timestamp: string; job_id?: string | null }

/**
 * Information about the Stump log file, located at `STUMP_CONFIG_DIR/Stump.log`, or
 * `~/.stump/Stump.log` by default. Information such as the file size, last modified date, etc.
 */
export type LogMetadata = { path: string; size: number; modified: string }

export type LogLevel = "ERROR" | "WARN" | "INFO" | "DEBUG"

export type PersistedJob = { id: string; name: string; description: string | null; status: JobStatus; output_data: CoreJobOutput | null; ms_elapsed: number; created_at: string; completed_at: string | null; logs?: Log[] | null }

export type CoreJobOutput = LibraryScanOutput | SeriesScanOutput | ThumbnailGenerationOutput

/**
 * An update event that is emitted by a job
 */
export type JobUpdate = ({ status?: JobStatus | null; message?: string | null; completed_tasks?: number | null; remaining_tasks?: number | null; completed_subtasks?: number | null; total_subtasks?: number | null }) & { id: string }

/**
 * A struct that represents a progress event that is emitted by a job. This behaves like a patch,
 * where the client will ignore any fields that are not present. This is done so all internal ops
 * can be done without needing to know the full state of the job.
 */
export type JobProgress = { status?: JobStatus | null; message?: string | null; completed_tasks?: number | null; remaining_tasks?: number | null; completed_subtasks?: number | null; total_subtasks?: number | null }

/**
 * The data that is collected and updated during the execution of a library scan job
 */
export type LibraryScanOutput = { total_files: number; total_directories: number; ignored_files: number; skipped_files: number; ignored_directories: number; created_media: number; updated_media: number; created_series: number; updated_series: number }

export type SeriesScanOutput = { total_files: number; ignored_files: number; skipped_files: number; created_media: number; updated_media: number }

export type ThumbnailGenerationJobVariant = ({ type: "SingleLibrary" } & string) | ({ type: "SingleSeries" } & string) | ({ type: "MediaGroup" } & string[])

export type ThumbnailGenerationJobParams = { variant: ThumbnailGenerationJobVariant; force_regenerate: boolean }

export type ThumbnailGenerationOutput = { visited_files: number; skipped_files: number; generated_thumbnails: number; removed_thumbnails: number }

export type User = { id: string; username: string; is_server_owner: boolean; avatar_url: string | null; created_at: string; last_login: string | null; is_locked: boolean; permissions: UserPermission[]; max_sessions_allowed?: number | null; login_sessions_count?: number | null; user_preferences?: UserPreferences | null; login_activity?: LoginActivity[] | null; age_restriction?: AgeRestriction | null; active_reading_sessions?: ActiveReadingSession[] | null; finished_reading_sessions?: FinishedReadingSession[] | null }

/**
 * A partial representation of a user, which does not include all fields. This should be
 * exposed to users within the system who do not have the necessary permissions to see
 * all fields of a user.
 */
export type PartialUser = { id: string; username: string; is_server_owner: boolean; avatar_url: string | null; created_at: string }

/**
 * Permissions that can be granted to a user. Some permissions are implied by others,
 * and will be automatically granted if the "parent" permission is granted.
 */
export type UserPermission = "feature:api_keys" | "feature:koreader_sync" | "bookclub:read" | "bookclub:create" | "emailer:read" | "emailer:create" | "emailer:manage" | "email:send" | "email:arbitrary_send" | "smartlist:read" | "file:explorer" | "file:upload" | "file:download" | "library:create" | "library:edit" | "library:scan" | "library:manage" | "library:delete" | "user:read" | "user:manage" | "notifier:read" | "notifier:create" | "notifier:manage" | "notifier:delete" | "server:manage"

export type AgeRestriction = { age: number; restrict_on_unset: boolean }

/**
 * An API key which can be used to interact with the API. API keys are scoped to a user,
 * so all actions taken with an API key are done as if the user was taking them.
 */
export type APIKey = { id: number; name: string; permissions: APIKeyPermissions; created_at: string; last_used_at: string | null; expires_at: string | null }

export type InheritPermissionValue = "inherit"

export type APIKeyPermissions = InheritPermissionValue | UserPermission[]

export type SupportedFont = "inter" | "opendyslexic"

export type NavigationMode = "SIDEBAR" | "TOPBAR"

export type HomeItem = { type: "ContinueReading" } | { type: "RecentlyAddedBooks" } | { type: "RecentlyAddedSeries" } | { type: "Library"; library_id: string } | { type: "SmartList"; smart_list_id: string }

export type NavigationItemDisplayOptions = { show_create_action?: boolean; show_link_to_all?: boolean }

export type NavigationItem = { type: "Home" } | { type: "Explore" } | ({ type: "Libraries" } & NavigationItemDisplayOptions) | ({ type: "SmartLists" } & NavigationItemDisplayOptions) | ({ type: "BookClubs" } & NavigationItemDisplayOptions)

export type ArrangementItem<I> = { item: I; visible?: boolean }

export type Arrangement<I> = { locked: boolean; items: ArrangementItem<I>[] }

export type UserPreferences = { id: string; locale: string; app_theme: string; enable_gradients?: boolean; app_font?: SupportedFont; show_query_indicator?: boolean; enable_live_refetch?: boolean; preferred_layout_mode?: string; primary_navigation_mode?: string; layout_max_width_px?: number | null; enable_discord_presence?: boolean; enable_compact_display?: boolean; enable_double_sidebar?: boolean; enable_hide_scrollbar?: boolean; enable_replace_primary_sidebar?: boolean; prefer_accent_color?: boolean; show_thumbnails_in_headers?: boolean; enable_job_overlay?: boolean; navigation_arrangement?: Arrangement<NavigationItem>; home_arrangement?: Arrangement<HomeItem> }

export type LoginActivity = { id: string; ip_address: string; user_agent: string; authentication_successful: boolean; timestamp: string; user?: User | null }

export type EmailerSendTo = { device_id: number } | { email: string }

/**
 * The config for an SMTP emailer
 */
export type EmailerConfig = { sender_email: string; sender_display_name: string; username: string; smtp_host: string; smtp_port: number; tls_enabled: boolean; max_attachment_size_bytes: number | null; max_num_attachments: number | null }

/**
 * The configuration for an [EmailerClient]
 */
export type EmailerClientConfig = { sender_email: string; sender_display_name: string; username: string; password: string | null; host: string; port: number; tls_enabled: boolean; max_attachment_size_bytes: number | null; max_num_attachments: number | null }

/**
 * An SMTP emailer entity, which stores SMTP configuration data to be used for sending emails.
 * 
 * will be configurable. This will be expanded in the future.
 */
export type SMTPEmailer = { id: number; name: string; is_primary: boolean; config: EmailerConfig; last_used_at: string | null }

export type RegisteredEmailDevice = { id: number; name: string; email: string; forbidden: boolean }

/**
 * A record of an email that was sent, used to keep track of emails that
 * were sent by specific emailer(s)
 */
export type EmailerSendRecord = { id: number; emailer_id: number; recipient_email: string; attachment_meta: AttachmentMeta[] | null; sent_at: string; sent_by_user_id: string | null; sent_by?: User | null }

/**
 * The metadata of an attachment that was sent with an email
 */
export type AttachmentMeta = { filename: string; media_id: string | null; size: number }

export type ReadingDirection = "ltr" | "rtl"

export type ReadingMode = "paged" | "continuous:vertical" | "continuous:horizontal"

export type ReadingImageScaleFit = "height" | "width" | "none"

export type FileStatus = "UNKNOWN" | "READY" | "UNSUPPORTED" | "ERROR" | "MISSING"

export type Library = { id: string; name: string; description: string | null; emoji: string | null; path: string; status: string; updated_at: string; series: Series[] | null; tags: Tag[] | null; config: LibraryConfig }

export type LibraryPattern = "SERIES_BASED" | "COLLECTION_BASED"

export type LibraryScanMode = "DEFAULT" | "NONE"

export type CustomVisit = { regen_meta: boolean; regen_hashes: boolean }

export type ScanConfig = null | { force_rebuild: boolean } | CustomVisit

/**
 * The override options for a scan job. These options are used to override the default behavior, which generally
 * means that the scanner will visit books it otherwise would not. How much extra work is done depends on the
 * specific options.
 */
export type ScanOptions = { config?: ScanConfig }

export type LastLibraryScan = { options: ScanOptions | null; timestamp: string }

export type IgnoreRules = string[]

export type LibraryConfig = { id?: string | null; convert_rar_to_zip: boolean; hard_delete_conversions: boolean; generate_file_hashes: boolean; generate_koreader_hashes: boolean; process_metadata: boolean; library_pattern: LibraryPattern; thumbnail_config: ImageProcessorOptions | null; default_reading_dir?: ReadingDirection; default_reading_mode?: ReadingMode; default_reading_image_scale_fit?: ReadingImageScaleFit; ignore_rules?: IgnoreRules; library_id?: string | null }

export type LibraryStats = { series_count: number; book_count: number; total_bytes: number; completed_books: number; in_progress_books: number }

export type SeriesMetadata = { _type: string; title: string | null; summary: string | null; publisher: string | null; imprint: string | null; comicid: number | null; volume: number | null; booktype: string | null; age_rating: number | null; status: string | null }

export type Series = { id: string; name: string; path: string; description: string | null; status: FileStatus; updated_at: string; created_at: string; library_id: string; library: Library | null; media: Media[] | null; metadata: SeriesMetadata | null; media_count?: number | null; unread_media_count?: number | null; tags?: Tag[] | null }

/**
 * Struct representing the metadata for a processed file.
 */
export type MediaMetadata = { title?: string | null; series?: string | null; number?: number | null; volume?: number | null; summary?: string | null; notes?: string | null; age_rating?: number | null; genre?: string[] | null; year?: number | null; month?: number | null; day?: number | null; writers?: string[] | null; pencillers?: string[] | null; inkers?: string[] | null; colorists?: string[] | null; letterers?: string[] | null; cover_artists?: string[] | null; editors?: string[] | null; publisher?: string | null; links?: string[] | null; characters?: string[] | null; teams?: string[] | null; page_count?: number | null; page_dimensions?: PageDimensionsEntity | null }

export type Media = { id: string; name: string; size: number; extension: string; pages: number; updated_at: string; created_at: string; modified_at: string | null; hash: string | null; koreader_hash: string | null; path: string; status: FileStatus; series_id: string; metadata: MediaMetadata | null; series?: Series | null; active_reading_session?: ActiveReadingSession | null; finished_reading_sessions: FinishedReadingSession[] | null; current_page?: number | null; current_epubcfi?: string | null; is_completed?: boolean | null; tags?: Tag[] | null; bookmarks?: Bookmark[] | null }

/**
 * A model representing a bookmark in the database. Bookmarks are used to save specific locations
 * in a media file, such as an epub, without any additional metadata like notes, tags, etc.
 */
export type Bookmark = { id: string; preview_content: string | null; epubcfi: string | null; page: number | null; book_id: string; book?: Media | null; user_id?: string | null; user?: User | null }

export type MediaAnnotation = { id: string; highlighted_text: string | null; page: number | null; page_coordinates_x: number | null; page_coordinates_y: number | null; epubcfi: string | null; notes: string | null; media_id: string; media?: Media | null }

export type ActiveReadingSession = { id: string; page: number | null; epubcfi: string | null; percentage_completed: number | null; elapsed_seconds: number | null; started_at: string; media_id: string; media: Media | null; user_id: string; user: User | null }

export type FinishedReadingSession = { id: string; started_at: string; completed_at: string; elapsed_seconds: number | null; media_id: string; media: Media | null; user_id: string; user: User | null }

export type ProgressUpdateReturn = ActiveReadingSession | FinishedReadingSession

/**
 * Represents a page dimension for a page of a Stump media item. It consists of a
 * height and a width.
 */
export type PageDimension = { height: number; width: number }

/**
 * Represents a database [`page_dimensions::Data`] object.
 * 
 * The `dimensions` member contains a [Vec]<[`PageDimension`]> containing the height and width
 * of each page for the media attached to the metadata for this entity.
 */
export type PageDimensionsEntity = { id: string; dimensions: PageDimension[]; metadata_id: string }

/**
 * A struct representing a sort order for a column using react-table (tanstack)
 */
export type ReactTableColumnSort = { id: string; position: number }

/**
 * A struct representing a global sort order for a table using react-table (tanstack)
 */
export type ReactTableGlobalSort = { desc: boolean; id: string }

/**
 * A filter for a single value, e.g. `name = "test"`
 */
export type Filter<T> = { equals: T } | { not: T } | { contains: T } | { excludes: T } | { any: T[] } | { none: T[] } | NumericFilter<T>

export type NumericFilter<T> = { gt: T } | { gte: T } | { lt: T } | { lte: T } | NumericRange<T>

export type NumericRange<T> = { from: T; to: T; inclusive?: boolean }

/**
 * A list of filters that are being combined with a logical operator, e.g. `and` or `or`
 */
export type FilterGroup<T> = { and: T[] } | { or: T[] } | { not: T[] }

export type FilterJoin = "AND" | "OR"

export type SmartListItemGrouping = "BY_BOOKS" | "BY_SERIES" | "BY_LIBRARY"

export type SmartListItemGroup<E> = { entity: E; books: Media[] }

export type SmartListItems = { type: "Books"; items: Media[] } | { type: "Series"; items: SmartListItemGroup<Series>[] } | { type: "Library"; items: SmartListItemGroup<Library>[] }

export type SmartList = { id: string; name: string; description: string | null; filters: SmartFilter<MediaSmartFilter>; visibility: EntityVisibility; joiner: FilterJoin; default_grouping: SmartListItemGrouping; saved_views: SmartListView[] | null; creator_id?: string | null }

export type SmartFilter<T> = { groups: FilterGroup<T>[] }

export type MediaSmartFilter = { name: Filter<string> } | { size: Filter<number> } | { extension: Filter<string> } | { created_at: Filter<string> } | { updated_at: Filter<string> } | { status: Filter<string> } | { path: Filter<string> } | { pages: Filter<number> } | { metadata: MediaMetadataSmartFilter } | { series: SeriesSmartFilter }

export type MediaMetadataSmartFilter = { title: Filter<string> } | { publisher: Filter<string> } | { genre: Filter<string> } | { characters: Filter<string> } | { colorists: Filter<string> } | { writers: Filter<string> } | { pencillers: Filter<string> } | { letterers: Filter<string> } | { inkers: Filter<string> } | { editors: Filter<string> } | { age_rating: Filter<number> } | { year: Filter<number> } | { month: Filter<number> } | { day: Filter<number> }

export type SeriesMetadataSmartFilter = { age_rating: Filter<number> } | { meta_type: Filter<string> } | { title: Filter<string> } | { summary: Filter<string> } | { publisher: Filter<string> } | { imprint: Filter<string> } | { comicid: Filter<number> } | { booktype: Filter<string> } | { volume: Filter<number> } | { status: Filter<string> }

export type SeriesSmartFilter = { name: Filter<string> } | { path: Filter<string> } | { metadata: SeriesMetadataSmartFilter } | { library: LibrarySmartFilter }

export type LibrarySmartFilter = { id: Filter<string> } | { name: Filter<string> } | { path: Filter<string> } | { created_at: Filter<string> } | { updated_at: Filter<string> }

export type SmartListView = ({ book_columns: ReactTableColumnSort[]; group_columns: ReactTableColumnSort[]; book_sorting: ReactTableGlobalSort[] | null; group_sorting: ReactTableGlobalSort[] | null; enable_multi_sort?: boolean | null; search?: string | null }) & { name: string; list_id: string }

export type BookClub = { id: string; name: string; description: string | null; emoji: string | null; is_private: boolean; created_at: string; member_role_spec: BookClubMemberRoleSpec; members?: BookClubMember[] | null; schedule?: BookClubSchedule | null }

export type BookClubMember = { id: string; display_name?: string | null; is_creator: boolean; hide_progress: boolean; private_membership: boolean; role: BookClubMemberRole; user?: PartialUser | null; user_id?: string | null; book_club?: BookClub | null }

export type BookClubMemberRole = "MEMBER" | "MODERATOR" | "ADMIN" | "CREATOR"

export type BookClubMemberRoleSpec = Record<BookClubMemberRole, string>

export type BookClubSchedule = { default_interval_days?: number | null; books?: BookClubBook[] | null }

export type BookClubExternalBook = { title: string; author: string; url?: string | null; image_url?: string | null }

export type BookClubBookDetails = ({ __type: "stored" } & Media) | ({ __type: "external" } & BookClubExternalBook)

export type BookClubBook = { id: string; start_at: string; end_at: string; discussion_duration_days?: number | null; book?: BookClubBookDetails | null; discussion?: BookClubDiscussion | null }

export type BookClubDiscussion = { id: string; messages: BookClubDiscussionMessage[] | null }

export type BookClubDiscussionMessage = { id: string; content: string; timestamp: string; is_top_message: boolean; child_messages?: BookClubDiscussionMessage[] | null; likes?: BookClubDiscussionMessageLike[] | null; member?: BookClubMember | null }

export type BookClubDiscussionMessageLike = { id: string; timestamp: string; liked_by?: BookClubMember | null }

export type BookClubInvitation = { id: string; user?: User | null; book_club?: BookClub | null }

export type Tag = { id: string; name: string }

export type LayoutMode = "GRID" | "TABLE"

export type Epub = { media_entity: Media; spine: string[]; resources: { [key: string]: [string, string] }; toc: EpubContent[]; metadata: { [key: string]: string[] }; annotations: MediaAnnotation[] | null; root_base: string; root_file: string; extra_css: string[] }

export type UpdateEpubProgress = { epubcfi: string; percentage: number; is_complete: boolean | null }

export type EpubContent = { label: string; content: string; children: EpubContent[]; play_order: number }

export type JobStatus = "RUNNING" | "PAUSED" | "COMPLETED" | "CANCELLED" | "FAILED" | "QUEUED"

export type JobSchedulerConfig = { id: string; interval_secs: number; excluded_libraries: Library[] }

export type ReadingListItem = { display_order: number; media_id: string; reading_list_id: string; media: Media | null }

export type ReadingListVisibility = "PUBLIC" | "PRIVATE" | "SHARED"

export type ReadingList = { id: string; name: string; creating_user_id: string; visibility: ReadingListVisibility; description: string | null; items: ReadingListItem[] | null }

export type CreateReadingList = { id: string; media_ids: string[]; visibility: ReadingListVisibility | null }

/**
 * The resize mode to use when generating a thumbnail.
 */
export type ImageResizeMode = "Scaled" | "Sized"

/**
 * The resize options to use when generating a thumbnail.
 * When using `Scaled`, the height and width will be scaled by the given factor.
 */
export type ImageResizeOptions = { mode: ImageResizeMode; height: number; width: number }

export type ScaledDimensionResize = { height: number } | { width: number }

/**
 * Supported image formats for processing images throughout Stump.
 */
export type ImageFormat = "Webp" | "Jpeg" | "Png"

/**
 * Options for processing images throughout Stump.
 */
export type ImageProcessorOptions = { resize_options?: ImageResizeOptions | null; format: ImageFormat; quality?: number | null; page?: number | null }

export type DirectoryListing = { parent: string | null; files: DirectoryListingFile[] }

export type DirectoryListingFile = { is_directory: boolean; name: string; path: string }

export type DirectoryListingInput = ({ ignore_hidden?: boolean; ignore_files?: boolean; ignore_directories?: boolean }) & { path: string | null }

export type Direction = "asc" | "desc"

export type QueryOrder<O> = { order_by?: O; direction?: Direction }

export type MediaOrderBy = "name" | "size" | "extension" | "created_at" | "updated_at" | "status" | "path" | "pages" | { metadata: MediaMetadataOrderBy[] }

export type MediaMetadataOrderBy = "title" | "series" | "number" | "volume" | "summary" | "notes" | "age_rating" | "genre" | "year" | "month" | "day" | "writers" | "pencillers" | "inkers" | "colorists" | "letterers" | "cover_artists" | "editors" | "publisher" | "links" | "characters" | "teams"

export type SeriesOrderBy = "name" | "description" | "updated_at" | "created_at" | "path" | "status"

export type SeriesMetadataOrderBy = "title" | "meta_type" | "summary" | "publisher" | "imprint" | "comicid" | "volume" | "booktype" | "age_rating" | "status"

export type LibraryOrderBy = "name" | "path" | "status" | "updated_at" | "created_at"

export type LogOrderBy = "timestamp" | "level" | "message" | "job_id"

export type JobOrderBy = "name" | "status" | "created_at" | "completed_at"

export type PageParams = { zero_based: boolean; page: number; page_size: number }

export type PageQuery = { zero_based?: boolean | null; page?: number | null; page_size?: number | null }

export type CursorQuery = { cursor?: string | null; limit?: number | null }

export type CursorInfo = { current_cursor: string | null; limit: number | null; next_cursor: string | null }

export type PageInfo = { total_pages: number; current_page: number; page_size: number; page_offset: number; zero_based: boolean }

export type Pagination = null | PageQuery | CursorQuery

// SERVER TYPE GENERATION

export type ClaimResponse = { is_claimed: boolean }

export type StumpVersion = { semver: string; rev: string; compile_time: string }

export type UpdateCheck = { current_semver: string; latest_semver: string; has_update_available: boolean }

export type AuthenticationOptions = { generate_token?: boolean; create_session?: boolean }

export type CreatedToken = { access_token: string; expires_at: string }

export type LoginResponse = User | { for_user: User; token: CreatedToken }

export type LoginOrRegisterArgs = { username: string; password: string }

export type CreateUser = { username: string; password: string; permissions?: UserPermission[]; age_restriction: AgeRestriction | null; max_sessions_allowed?: number | null }

export type UpdateUser = { username: string; password: string | null; avatar_url: string | null; permissions?: UserPermission[]; age_restriction: AgeRestriction | null; max_sessions_allowed?: number | null }

export type UpdateUserPreferences = { id: string; locale: string; preferred_layout_mode: string; primary_navigation_mode: string; layout_max_width_px: number | null; app_theme: string; enable_gradients: boolean; app_font: SupportedFont; show_query_indicator: boolean; enable_live_refetch: boolean; enable_discord_presence: boolean; enable_compact_display: boolean; enable_double_sidebar: boolean; enable_replace_primary_sidebar: boolean; enable_hide_scrollbar: boolean; enable_job_overlay: boolean; prefer_accent_color: boolean; show_thumbnails_in_headers: boolean }

export type DeleteUser = { hard_delete: boolean | null }

/**
 * The request body for creating or updating an API key
 */
export type CreateOrUpdateAPIKey = { name: string; permissions: APIKeyPermissions; expires_at?: string | null }

/**
 * The response after creating a new API key
 */
export type CreatedAPIKey = { api_key: string }

export type EmailerIncludeParams = { include_send_history?: boolean }

export type EmailerSendRecordIncludeParams = { include_sent_by?: boolean }

export type SendAttachmentEmailsPayload = { media_ids: string[]; send_to: EmailerSendTo[] }

export type SendAttachmentEmailResponse = { sent_emails_count: number; errors: string[] }

/**
 * Input object for creating or updating an emailer
 */
export type CreateOrUpdateEmailer = { name: string; is_primary: boolean; config: EmailerClientConfig }

/**
 * Input object for creating or updating an email device
 */
export type CreateOrUpdateEmailDevice = { name: string; email: string; forbidden: boolean }

/**
 * Patch an existing email device by its ID
 */
export type PatchEmailDevice = { name: string | null; email: string | null; forbidden: boolean | null }

/**
 * A filter body for more complex filtering and ordering operations. It uses the
 * smart filter types as its backbone. This should be used only in request bodies,
 * not query strings. For query strings, use [`super::FilterQuery`].
 */
export type FilterBody<F, O> = { filters?: FilterGroup<F>[]; order_params?: QueryOrder<O>[] }

export type LogFilter = { level?: LogLevel | null; job_id?: string | null; timestamp?: ValueOrRange<string> | null }

export type LibraryBaseFilter = { id?: string[]; name?: string[]; path?: string[]; search?: string | null }

export type LibraryRelationFilter = { series?: SeriesBaseFilter | null }

export type LibraryFilter = ({ id?: string[]; name?: string[]; path?: string[]; search?: string | null }) & ({ series?: SeriesBaseFilter | null })

/**
 * A user-friendly representation of a media's `read_progress`. This will map to
 * a query condition that will be used to filter the media.
 */
export type ReadStatus = "Unread" | "Reading" | "Completed"

export type MediaMetadataBaseFilter = { publisher?: string[]; genre?: string[]; character?: string[]; colorist?: string[]; writer?: string[]; penciller?: string[]; inker?: string[]; letterer?: string[]; editor?: string[]; age_rating?: number | null; year?: ValueOrRange<number> | null }

export type MediaMetadataRelationFilter = { media?: MediaFilter | null }

export type MediaMetadataFilter = ({ publisher?: string[]; genre?: string[]; character?: string[]; colorist?: string[]; writer?: string[]; penciller?: string[]; inker?: string[]; letterer?: string[]; editor?: string[]; age_rating?: number | null; year?: ValueOrRange<number> | null }) & ({ media?: MediaFilter | null })

export type MediaBaseFilter = { id?: string[]; name?: string[]; extension?: string[]; path?: string[]; read_status?: ReadStatus[]; tags?: string[]; search?: string | null; metadata?: MediaMetadataBaseFilter | null }

export type MediaFilter = ({ id?: string[]; name?: string[]; extension?: string[]; path?: string[]; read_status?: ReadStatus[]; tags?: string[]; search?: string | null; metadata?: MediaMetadataBaseFilter | null }) & ({ series?: SeriesFilter | null })

export type PutMediaProgress = { page: number; epubcfi?: string | null; elapsed_seconds?: number | null }

/**
 * Represents the relations to load for a book entity, including optional loading
 * of the series and library relationships.
 */
export type BookRelations = { load_series?: boolean | null; load_library?: boolean | null; load_pages?: boolean | null }

export type SeriesBaseFilter = { id?: string[]; name?: string[]; path?: string[]; search?: string | null; metadata?: SeriesMetadataFilter | null }

export type SeriesMetadataFilter = { meta_type?: string[]; publisher?: string[]; status?: string[]; age_rating?: number | null; volume?: ValueOrRange<number> | null }

export type SeriesFilter = ({ id?: string[]; name?: string[]; path?: string[]; search?: string | null; metadata?: SeriesMetadataFilter | null }) & ({ library?: LibraryBaseFilter | null; media?: MediaBaseFilter | null })

export type ValueOrRange<T> = T | Range<T>

export type Range<T> = { from?: T | null; to?: T | null }

export type UserQueryRelation = { include_read_progresses?: boolean | null; include_session_count?: boolean | null; include_restrictions?: boolean | null }

export type SeriesQueryRelation = { load_media?: boolean | null; load_library?: boolean | null; count_media?: boolean | null }

export type CreateLibrary = { name: string; path: string; description?: string | null; tags?: string[] | null; scan_mode?: LibraryScanMode | null; config?: LibraryConfig | null }

export type UpdateLibrary = { name: string; path: string; description?: string | null; emoji?: string | null; tags?: string[] | null; config: LibraryConfig; scan_mode?: LibraryScanMode | null }

export type UpdateLibraryExcludedUsers = { user_ids: string[] }

export type CleanLibraryResponse = { deleted_media_count: number; deleted_series_count: number; is_empty: boolean }

export type GenerateLibraryThumbnails = { image_options?: ImageProcessorOptions | null; force_regenerate?: boolean }

export type LibraryStatsParams = { all_users?: boolean }

/**
 * Represents an update to the completion status of a media item.
 */
export type PutMediaCompletionStatus = { is_complete: boolean; page?: number | null }

/**
 * Represents whether a media item is marked as completed and the last time it was completed.
 */
export type MediaIsComplete = { is_completed: boolean; last_completed_at: string | null }

export type MediaMetadataOverview = { genres: string[]; writers: string[]; pencillers: string[]; inkers: string[]; colorists: string[]; letterers: string[]; editors: string[]; publishers: string[]; characters: string[]; teams: string[] }

export type CreateOrUpdateBookmark = { epubcfi: string; preview_content: string | null }

export type DeleteBookmark = { epubcfi: string }

export type SeriesIsComplete = { is_complete: boolean; completed_at: string | null }

export type UpdateSchedulerConfig = { interval_secs: number | null; excluded_library_ids: string[] | null }

export type GetBookClubsParams = { all?: boolean }

export type CreateBookClub = { name: string; is_private?: boolean; member_role_spec?: BookClubMemberRoleSpec | null; creator_hide_progress?: boolean; creator_display_name?: string | null }

export type UpdateBookClub = { name?: string | null; description?: string | null; is_private?: boolean | null; member_role_spec?: BookClubMemberRoleSpec | null; emoji?: string | null }

export type CreateBookClubInvitation = { user_id: string; role?: BookClubMemberRole | null }

export type BookClubInvitationAnswer = { accept: boolean; member_details: CreateBookClubMember | null }

export type CreateBookClubMember = { user_id: string; display_name: string | null; private_membership: boolean | null }

export type UpdateBookClubMember = { display_name: string | null; private_membership: boolean | null }

/**
 * An enum to represent the two options for a book in a book club schedule:
 * 
 * - A book that is stored in the database
 * - A book that is not stored in the database
 * 
 * This provides some flexibility for book clubs to add books that perhaps are not on the server
 */
export type CreateBookClubScheduleBookOption = { id: string } | BookClubExternalBook

export type CreateBookClubScheduleBook = { book: CreateBookClubScheduleBookOption; start_at?: string | null; end_at?: string | null; discussion_duration_days?: number | null }

export type CreateBookClubSchedule = { default_interval_days?: number | null; books: CreateBookClubScheduleBook[] }

/**
 * Request body for updating a media's thumbnail using a specific page from the media.
 * 
 * The `page` field specifies the page to be used to generate a thumbnail. The
 * `is_zero_based` field  can be set to `true` if the page numbering starts from
 * `0`. This will add 1 to the indicated `page`. A `None` value is the same
 * as passing `Some(false)`.
 */
export type PatchMediaThumbnail = { page: number; is_zero_based?: boolean | null }

export type PatchSeriesThumbnail = { media_id: string; page: number; is_zero_based?: boolean | null }

export type PatchLibraryThumbnail = { media_id: string; page: number; is_zero_based?: boolean | null }

export type LibraryScanRecord = { id: number; options: ScanOptions | null; timestamp: string; library_id: string; job_id: string | null }

export type LastScanDetails = { last_scanned_at: string | null; last_scan: LastLibraryScan | null }

export type CreateOrUpdateSmartList = { name: string; description: string | null; filters: SmartFilter<MediaSmartFilter>; joiner?: FilterJoin | null; default_grouping?: SmartListItemGrouping | null; visibility?: EntityVisibility | null }

export type GetSmartListsParams = { all?: boolean | null; mine?: boolean | null; search?: string | null }

export type SmartListRelationOptions = { load_views?: boolean }

export type SmartListMeta = { matched_books: number; matched_series: number; matched_libraries: number }

export type CreateOrUpdateSmartListView = ({ book_columns: ReactTableColumnSort[]; group_columns: ReactTableColumnSort[]; book_sorting: ReactTableGlobalSort[] | null; group_sorting: ReactTableGlobalSort[] | null; enable_multi_sort?: boolean | null; search?: string | null }) & { name: string }

export type UploadConfig = { enabled: boolean; max_file_upload_size: number }

/**
 * Represents the configuration of a Stump application. This struct is generated at startup
 * using a TOML file, environment variables, or both and is input when creating a `StumpCore`
 * instance.
 * 
 * Example:
 * ```
 * use stump_core::{config::{self, StumpConfig}, StumpCore};
 * 
 * #[tokio::main]
 * async fn main() {
 * /// Get config dir from environment variables.
 * let config_dir = config::bootstrap_config_dir();
 * 
 * // Create a StumpConfig using the config file and environment variables.
 * let config = StumpConfig::new(config_dir)
 * // Load Stump.toml file (if any)
 * .with_config_file().unwrap()
 * // Overlay environment variables
 * .with_environment().unwrap();
 * 
 * // Ensure that config directory exists and write Stump.toml.
 * config.write_config_dir().unwrap();
 * // Create an instance of the stump core.
 * let core = StumpCore::new(config).await;
 * }
 * ```
 */
export type StumpConfig = { profile: string; port: number; verbosity: number; pretty_logs: boolean; db_path: string | null; client_dir: string; custom_templates_dir: string | null; config_dir: string; allowed_origins: string[]; pdfium_path: string | null; enable_swagger: boolean; enable_koreader_sync: boolean; password_hash_cost: number; session_ttl: number; access_token_ttl: number; expired_session_cleanup_interval: number; max_scanner_concurrency: number; max_thumbnail_concurrency: number; max_image_upload_size: number; enable_upload: boolean; max_file_upload_size: number }

// DESKTOP TYPE GENERATION

export type SavedServer = { name: string; uri: string }

export type DesktopAppStore = { run_bundled_server: boolean; active_server?: SavedServer | null; connected_servers: SavedServer[] }

export type CredentialStoreTokenState = { [key: string]: boolean }

